---
title: "矩阵快速幂学习笔记"
description: "如题"
pubDate: "Dec 18 2024"
image: "/head_pic/NahidA_4.webp"
categories:
  - tech
tags:
  - 学习笔记
---

这矩阵快速幂多是一件美事啊  
只用推式子，而且这式子也是十分好推。

## [P1962 斐波那契数列](https://www.luogu.com.cn/problem/P1962)

是个人第一眼看到这题，第一眼都会想着递推。但是如果真这么简单的话，它就不会是绿题了。我们一看数据范围：$n \le 2^{63}$ 。$\mathcal{O}(n)$ 不给你全部炸完？  
先来推式子：$f_{i} = f_{i - 1} + f_{i - 2} , f_{i - 1} = f_{i - 1}$ 。我们把他整理一下：

$$
\left\{
  \begin{aligned}
  f_{i} & = 1 \times f_{i - 1} + 1 \times f_{i - 2} \\
  f_{i - 1} & = 1 \times f_{i - 1} + 0 \times f_{i - 2}
  \end{aligned}
\right.
$$

我们一看，这可以用矩阵来表示啊：

$$
\begin{bmatrix}
1 & 1 \\
1 & 0
\end{bmatrix}
\begin{bmatrix}
f_{i - 1} \\
f_{i - 2}
\end{bmatrix}
=
\begin{bmatrix}
f_{i} \\
f_{i - 1}
\end{bmatrix}
$$

而我们又看：

$$
\begin{bmatrix}
1 & 1 \\
1 & 0
\end{bmatrix}^1
\begin{bmatrix}
f_{i - 1} \\
f_{i - 2}
\end{bmatrix}
=
\begin{bmatrix}
f_{i} \\
f_{i - 1}
\end{bmatrix}
\\
\begin{bmatrix}
1 & 1 \\
1 & 0
\end{bmatrix}^2
\begin{bmatrix}
f_{i - 2} \\
f_{i - 3}
\end{bmatrix}
=
\begin{bmatrix}
f_{i} \\
f_{i - 1}
\end{bmatrix}
$$

发现什么端倪没有？如果我们一直往前推，定能推到 $\begin{bmatrix}f_{2} \\ f_{1}\end{bmatrix}$ 。而我们看：往前推一次，要乘转矩阵的 $1$ 次方，$f_{i}$ 变成 $f_{i - 1}$ 。而我们最终要从 $f_{n}$ 变成 $f_{2}$ ，也就是 $f_{n - (n - 2)}$ ，那么我们就可以知道，推到 $\begin{bmatrix}f_{2} \\ f_{1}\end{bmatrix}$ 要乘转移矩阵 $\begin{bmatrix} 1 & 1 \\ 1 & 0 \end{bmatrix}$ 的 $n - 2$ 次方。也就是 $\begin{bmatrix}f_{n} \\ f_{n - 1}\end{bmatrix} = \begin{bmatrix} 1 & 1 \\ 1 & 0 \end{bmatrix}^{n - 2}\begin{bmatrix}1 \\ 1 \end{bmatrix}$ 。那么我们就可以用矩阵快速幂来做咯。**注意**：矩阵乘法没有交换律，一定注意矩阵乘法的顺序。  
code:

```cpp
#include<bits/extc++.h>
#define int long long
using namespace std;
const int mod = 1e9 + 7;
int n;
struct mat{
    int a[2][2];
    mat(int x = 0){memset(a,0,sizeof a);a[0][0] = a[1][1] = x;};
    mat operator*(mat x)
    {
        mat ret;
        for (int i = 0; i < 2; i++)
            for (int j = 0; j < 2; j++)
                for (int k = 0; k < 2; k++)
                    ret.a[i][j] = (ret.a[i][j] + a[i][k] * x.a[k][j] % mod) % mod;
        return ret;
    }
}base,tmp;
template<typename type>type binpow(type x,int y)
{
    type ret(1);
    while (y)
    {
        if (y & 1)
            ret = ret * x;
        x = x * x;
        y >>= 1;
    }
    return ret;
}
signed main()
{
    scanf("%lld",&n);
    if (n == 1)
    {
        printf("1");
        return 0;
    }
    base.a[0][0] = 1;
    base.a[0][1] = 1;
    base.a[1][0] = 1;
    base.a[1][1] = 0;
    base = binpow(base,n - 2);
    tmp.a[0][0] = tmp.a[0][1] = 1;
    printf("%lld",(tmp * base).a[0][0]);
    return 0;
}
```